<div class="overall-wrapper" appMaximize #nestjsMiddleware="maximize" id="nestjsMiddleware">
  <div class="wrapper">
       <img class="swap" *ngIf="nestjsMiddleware.checkfullscreen() == 'hide'" (click)="nestjsMiddleware.toggle()" src="../../../assets/expand.svg" alt="Expand">
       <img class="swap" *ngIf="nestjsMiddleware.checkfullscreen() != 'hide'" (click)="nestjsMiddleware.toggle()" src="../../../assets/Minimize icon.svg" alt="Minimize">
      <div class="header">
          <p>
            <span class="question">What:</span>
            In NestJS, <strong>Middleware</strong> is a function or class that runs
            <strong>before your controller methods (&#64;Get, &#64;Post, etc.)</strong>.
            It can check, log, or modify the request before it reaches the controller.
          </p>
          <p>
            <span class="question">Why:</span>
            Middleware is useful for <strong>common tasks</strong> like logging requests,
            checking authentication, or validating inputs. This prevents repeating
            the same code in every controller.
          </p>
          <p>
            <span class="question">Where:</span>
            You can use Middleware in <strong>REST APIs, GraphQL, or microservices</strong>
            whenever you need to process requests before they go to controllers.
          </p>
        </div>
   </div>
   
   <div class="examples">
      <div style="width: 100%;display: flex;justify-content: center;align-items: center; background-color: rgb(90, 87, 87);padding: 10px;">
            <img src="../../../assets/Middlewares_1.png"  width="70%" height="70%"  alt="">
    </div>
     <div class="step">
       <h2>1. Basic Middleware Setup</h2>
       <p>Create a simple middleware to log requests:</p>
       
       <h3>Logger Middleware</h3>
       <pre><code>// logger.middleware.ts
import &#123; Injectable, NestMiddleware &#125; from '&#64;nestjs/common';
import &#123; Request, Response, NextFunction &#125; from 'express';

&#64;Injectable()
export class LoggerMiddleware implements NestMiddleware &#123;
  use(req: Request, res: Response, next: NextFunction) &#123;
    console.log(`Request: $&#123;req.method&#125; $&#123;req.originalUrl&#125; at $&#123;new Date().toISOString()&#125;`);
    next();
  &#125;
&#125;
</code></pre>

       <h3>Key Points</h3>
       <div class="feature-grid">
         <div class="feature-card">
           <h4>NestMiddleware</h4>
           <p>Interface that requires a <code>use</code> method</p>
         </div>
         <div class="feature-card">
           <h4>Request/Response</h4>
           <p>Gives access to request and response objects from Express</p>
         </div>
         <div class="feature-card">
           <h4>NextFunction</h4>
           <p>Continues to the next middleware or controller</p>
         </div>
         <div class="feature-card">
           <h4>Injectable</h4>
           <p>Allows dependency injection inside middleware</p>
         </div>
       </div>
     </div>

     <div class="step">
       <h2>2. Applying Middleware</h2>
       <p>Middleware can be added to specific routes, modules, or globally:</p>

       <h3>Step 1: Apply to a Module</h3>
       <p>Attach middleware to routes in a module:</p>
       <pre><code>// users.module.ts
import &#123; Module, NestModule, MiddlewareConsumer &#125; from '&#64;nestjs/common';
import &#123; UsersController &#125; from './users.controller';
import &#123; UsersService &#125; from './users.service';
import &#123; LoggerMiddleware &#125; from './logger.middleware';

&#64;Module(&#123;
  controllers: [UsersController],
  providers: [UsersService]
&#125;)
export class UsersModule implements NestModule &#123;
  configure(consumer: MiddlewareConsumer) &#123;
    consumer
      .apply(LoggerMiddleware)
      .forRoutes('api/users');
  &#125;
&#125;
</code></pre>

       <h3>Step 2: Apply Globally</h3>
       <pre><code>// main.ts
import &#123; NestFactory &#125; from '&#64;nestjs/core';
import &#123; AppModule &#125; from './app.module';
import &#123; LoggerMiddleware &#125; from './logger.middleware';

async function bootstrap() &#123;
  const app = await NestFactory.create(AppModule);
  app.use(new LoggerMiddleware().use.bind(new LoggerMiddleware()));
  await app.listen(3000);
&#125;
bootstrap();
</code></pre>

       <h3>Step 3: Middleware with Services</h3>
       <p>Middleware can use services via dependency injection:</p>
       <pre><code>// auth.middleware.ts
import &#123; Injectable, NestMiddleware, UnauthorizedException &#125; from '&#64;nestjs/common';
import &#123; Request, Response, NextFunction &#125; from 'express';
import &#123; UsersService &#125; from './users.service';

&#64;Injectable()
export class AuthMiddleware implements NestMiddleware &#123;
  constructor(private usersService: UsersService) &#123;&#125;

  use(req: Request, res: Response, next: NextFunction) &#123;
    const authHeader = req.headers.authorization;
    if (!authHeader) &#123;
      throw new UnauthorizedException('Authorization header missing');
    &#125;
    const userId = +authHeader.split(' ')[1]; 
    const user = this.usersService.findOne(userId);
    if (!user) &#123;
      throw new UnauthorizedException('Invalid user');
    &#125;
    req.user = user;
    next();
  &#125;
&#125;
</code></pre>

       <h3>Quick Recap</h3>
       <ul>
         <li>Middleware runs before controllers.</li>
         <li>Can be applied locally (module) or globally (main.ts).</li>
         <li>Supports dependency injection with <code>&#64;Injectable()</code>.</li>
       </ul>
     </div>

     <div class="step">
       <h2>3. Advanced Middleware Features</h2>
       <p>Some extra features of middleware:</p>

       <h3>Functional Middleware</h3>
       <pre><code>// request-id.middleware.ts
import &#123; Request, Response, NextFunction &#125; from 'express';

export function requestIdMiddleware(req: Request, res: Response, next: NextFunction) &#123;
  req['requestId'] = Math.random().toString(36).substring(2);
  next();
&#125;
</code></pre>

       <h3>Multiple Middleware</h3>
       <pre><code>// users.module.ts
consumer
  .apply(requestIdMiddleware, LoggerMiddleware, AuthMiddleware)
  .forRoutes(UsersController);
</code></pre>

       <h3>Exclude Routes</h3>
       <pre><code>// users.module.ts
consumer
  .apply(AuthMiddleware)
  .exclude(&#123; path: 'api/users', method: RequestMethod.GET &#125;)
  .forRoutes(UsersController);
</code></pre>

       <h3>Quick Recap</h3>
       <ul>
         <li>Use functional middleware for small tasks.</li>
         <li>You can chain multiple middleware together.</li>
         <li>You can skip middleware for certain routes.</li>
         <li>Middleware runs in the order you apply it.</li>
       </ul>
     </div>

     <div class="step">
       <h2>4. Best Practices</h2>
       <p>Tips to use middleware effectively:</p>
       
       <h3>Directory Example</h3>
       <pre><code>project/
├── src/
│   ├── users/
│   │   ├── middleware/
│   │   │   ├── logger.middleware.ts
│   │   │   ├── auth.middleware.ts
│   │   │   └── request-id.middleware.ts
│   │   ├── users.controller.ts
│   │   ├── users.service.ts
│   │   └── users.module.ts
│   ├── app.module.ts
│   └── main.ts
</code></pre>

       <h3>Best Practices</h3>
       <div class="feature-grid">
         <div class="feature-card">
           <h4>Single Purpose</h4>
           <p>Each middleware should handle one task only</p>
         </div>
         <div class="feature-card">
           <h4>Keep It Modular</h4>
           <p>Place middleware inside feature folders</p>
         </div>
         <div class="feature-card">
           <h4>Order is Important</h4>
           <p>Apply middleware in the correct sequence</p>
         </div>
         <div class="feature-card">
           <h4>Limit Scope</h4>
           <p>Apply only where needed</p>
         </div>
       </div>
     </div>

     <div class="interview-questions step">
       <h2>15 Common Interview Questions on Middleware</h2>
       <ol class="question-list">
         <li>
           <strong class="question-title">What is middleware in NestJS?</strong>
           <p class="answer">Middleware is code that runs before  a request hits a controller. It’s used for logging, security, or modifying requests.</p>
         </li>
         <li>
           <strong class="question-title">How do you create middleware?</strong>
           <p class="answer">By writing a class with <code>use</code> method (implements NestMiddleware) or a simple function with <code>req</code>, <code>res</code>, and <code>next</code>.</p>
         </li>
         <li>
           <strong class="question-title">What does the use method do?</strong>
           <p class="answer">It processes the request and then calls <code>next()</code> to move on.</p>
         </li>
         <li>
           <strong class="question-title">How do you apply middleware to a module?</strong>
           <p class="answer">By using <code>MiddlewareConsumer</code> inside the <code>configure</code> method of a module.</p>
         </li>
         <li>
           <strong class="question-title">How do you apply middleware globally?</strong>
           <p class="answer">In <code>main.ts</code>, call <code>app.use()</code> with your middleware.</p>
         </li>
         <li>
           <strong class="question-title">What is MiddlewareConsumer?</strong>
           <p class="answer">A helper that lets you attach middleware to specific routes or controllers.</p>
         </li>
         <li>
           <strong class="question-title">How can you exclude routes?</strong>
           <p class="answer">By calling <code>exclude()</code> in <code>MiddlewareConsumer</code>.</p>
         </li>
         <li>
           <strong class="question-title">Can middleware use services?</strong>
           <p class="answer">Yes, if you use class-based middleware with <code>&#64;Injectable()</code>.</p>
         </li>
         <li>
           <strong class="question-title">What’s the difference between function and class middleware?</strong>
           <p class="answer">Functions are simple. Classes support dependency injection and are better for complex logic.</p>
         </li>
         <li>
           <strong class="question-title">How do you run multiple middleware?</strong>
           <p class="answer">Pass multiple middleware in <code>apply()</code>.</p>
         </li>
         <li>
           <strong class="question-title">Why does order matter?</strong>
           <p class="answer">Because middleware runs in the same order you apply it.</p>
         </li>
         <li>
           <strong class="question-title">How do you handle errors?</strong>
           <p class="answer">Throw exceptions (like <code>UnauthorizedException</code>) or use <code>next(err)</code>.</p>
         </li>
         <li>
           <strong class="question-title">What are common use cases?</strong>
           <p class="answer">Logging, authentication, validation, rate limiting, etc.</p>
         </li>
         <li>
           <strong class="question-title">How do you test middleware?</strong>
           <p class="answer">By mocking <code>req</code>, <code>res</code>, and <code>next</code> in unit tests.</p>
         </li>
         <li>
           <strong class="question-title">How is middleware different from interceptors?</strong>
           <p class="answer">Middleware runs before controllers and works with raw requests. Interceptors run in the NestJS lifecycle and provide more advanced features.</p>
         </li>
       </ol>
     </div>
   </div>
</div>
