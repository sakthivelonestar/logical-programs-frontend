<div class="overall-wrapper" appMaximize #javascriptAsyncConcepts="maximize" id="javascriptAsyncConcepts">
  <div class="wrapper">
       <img class="swap" *ngIf="javascriptAsyncConcepts.checkfullscreen() == 'hide'" (click)="javascriptAsyncConcepts.toggle()" src="../../../assets/expand.svg" alt="Expand">
       <img class="swap" *ngIf="javascriptAsyncConcepts.checkfullscreen() != 'hide'" (click)="javascriptAsyncConcepts.toggle()" src="../../../assets/Minimize icon.svg" alt="Minimize">
      <div class="header">
        <p>
          <span class="question">What:</span>
          In JavaScript, <strong>Promises & Async/Await</strong> are mechanisms to handle asynchronous operations, making code easier to read and maintain.
        </p>
        <p>
          <span class="question">Why:</span>
          They help you <strong>manage asynchronous tasks</strong> such as API calls, file reading, or timers, avoiding deeply nested callbacks (callback hell).
        </p>
        <p>
          <span class="question">Where:</span>
          You can use them in <strong>web applications, Node.js servers, APIs,</strong> or any scenario involving asynchronous operations.
        </p>
      </div>
   </div>
   
   <div class="examples">
     <div class="step">
       <h2>1. Understanding Promises</h2>
       <p>Promises represent a value that may be available now, later, or never. They have three states: <strong>pending</strong>, <strong>fulfilled</strong>, and <strong>rejected</strong>.</p>

       <h3>Basic Promise Example</h3>
       <pre><code><span class="comment">// Create a new Promise</span>
const myPromise = new Promise((resolve, reject) =&gt; &#123;
  const success = true;
  if(success) &#123;
    resolve("Operation successful");
  &#125; else &#123;
    reject("Operation failed");
  &#125;
&#125;);

myPromise
  .then(result =&gt; console.log(result))   <span class="comment">// "Operation successful"</span>
  .catch(error =&gt; console.log(error));
</code></pre>

       <h3>Key Points</h3>
       <ul>
         <li>Use <code>resolve</code> to mark a promise as fulfilled.</li>
         <li>Use <code>reject</code> to mark a promise as failed.</li>
         <li>Attach <code>.then()</code> to handle success and <code>.catch()</code> for errors.</li>
       </ul>
     </div>

     <div class="step">
       <h2>2. Chaining Promises</h2>
       <p>Promises can be chained to handle sequential asynchronous operations:</p>
       <pre><code><span class="comment">// Chaining multiple asynchronous tasks</span>
const fetchData = () =&gt; &#123;
  return new Promise(resolve =&gt; setTimeout(() =&gt; resolve("Data received"), 1000));
&#125;;

fetchData()
  .then(data =&gt; &#123;
    console.log(data);             <span class="comment">// "Data received"</span>
    return "Next step";
  &#125;)
  .then(step =&gt; console.log(step)); <span class="comment">// "Next step"</span>
</code></pre>

       <h3>Key Points</h3>
       <ul>
         <li>Each <code>.then()</code> receives the resolved value from the previous promise.</li>
         <li>Return a new value or promise inside <code>.then()</code> for chaining.</li>
       </ul>
     </div>

     <div class="step">
       <h2>3. Async/Await Syntax</h2>
       <p>Async/Await is syntactic sugar over promises, allowing asynchronous code to look synchronous.</p>

       <h3>Basic Async/Await Example</h3>
       <pre><code><span class="comment">// Define an async function</span>
async function fetchUser() &#123;
  try &#123;
    const response = await fetch("https://jsonplaceholder.typicode.com/users/1");
    const data = await response.json();
    console.log(data);
  &#125; catch(error) &#123;
    console.log("Error:", error);
  &#125;
&#125;

fetchUser();
</code></pre>

       <h3>Key Points</h3>
       <ul>
         <li>Use <code>async</code> keyword before a function to make it asynchronous.</li>
         <li>Use <code>await</code> to wait for a promise to resolve.</li>
         <li>Wrap <code>await</code> calls in <code>try/catch</code> for error handling.</li>
       </ul>
     </div>

     <div class="step">
       <h2>4. Parallel Asynchronous Operations</h2>
       <p>Run multiple asynchronous tasks concurrently using <code>Promise.all</code>:</p>

       <pre><code><span class="comment">// Run multiple promises in parallel</span>
const promise1 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(10), 1000));
const promise2 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(20), 500));

Promise.all([promise1, promise2])
  .then(results =&gt; console.log(results)) <span class="comment">// [10, 20]</span>
  .catch(error =&gt; console.log(error));
</code></pre>

       <h3>Key Points</h3>
       <ul>
         <li><code>Promise.all</code> waits for all promises to resolve or rejects if any fail.</li>
         <li>Use <code>Promise.race</code> to get the first resolved/rejected promise.</li>
       </ul>
     </div>

     <div class="step">
       <h2>5. Error Handling Best Practices</h2>
       <p>Properly handle errors in promises and async/await to prevent unhandled rejections:</p>

       <pre><code><span class="comment">// Using .catch with Promises</span>
fetchData()
  .then(data =&gt; console.log(data))
  .catch(err =&gt; console.log("Error:", err));

<span class="comment">// Using try/catch with Async/Await</span>
async function loadData() &#123;
  try &#123;
    const data = await fetchData();
    console.log(data);
  &#125; catch(err) &#123;
    console.log("Error:", err);
  &#125;
&#125;
</code></pre>

       <h3>Key Points</h3>
       <ul>
         <li>Always attach <code>.catch()</code> for promises.</li>
         <li>Use <code>try/catch</code> inside async functions for reliable error handling.</li>
         <li>Helps maintain robust and predictable asynchronous workflows.</li>
       </ul>
     </div>
   </div>
</div>
