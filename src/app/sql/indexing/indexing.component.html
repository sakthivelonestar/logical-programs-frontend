 <div class="overall-wrapper" appMaximize #sqlAggregationFunctions="maximize" id="sqlStoredProceduresFunctions">
        <div class="wrapper">
            <img class="swap" *ngIf="sqlAggregationFunctions.checkfullscreen() ==  'hide'" (click)="sqlAggregationFunctions.toggle()" src="../../../assets/expand.svg" alt="Expand">
            <img class="swap" *ngIf="sqlAggregationFunctions.checkfullscreen() !=  'hide'" (click)="sqlAggregationFunctions.toggle()" src="../../../assets/Minimize icon.svg" alt="Minimize">
      
        <div class="header">
            <p><span class="question">What:</span> SQL indexes and constraints are <strong>tools that make databases faster and keep data accurate.</strong></p>
            <p><span class="question">Why:</span> They help <strong>speed up searches, prevent duplicate data, and ensure data follows your business rules.</strong></p>
            <p><span class="question">Where:</span> Used in <strong>any application that needs fast database queries and reliable data - like online stores, banking systems, and reporting tools.</strong></p>
        </div>
        </div>
        <div class="examples">
            <div class="step">
                <h4>Step 1: Basic Indexes and Primary Key Constraints</h4>
                <pre><code>-- Creating a table with a primary key constraint
CREATE TABLE employees (
    employee_id INT NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    salary DECIMAL(10,2),
    department_id INT,
    CONSTRAINT pk_employee PRIMARY KEY (employee_id)
);

-- Creating a basic index on salary column
CREATE INDEX idx_employee_salary ON employees(salary);

-- Creating a composite index on department_id and last_name
CREATE INDEX idx_employee_dept_name ON employees(department_id, last_name);

-- Query utilizing the index
SELECT employee_id, first_name, last_name, salary
FROM employees
WHERE salary > 50000
ORDER BY salary DESC;

-- Query utilizing composite index
SELECT employee_id, first_name, last_name
FROM employees
WHERE department_id = 1 AND last_name LIKE 'S%';
</code></pre>
                <p>Primary key constraints ensure <strong>uniqueness</strong> and <strong>non-nullability</strong> for employee_id, while indexes on salary and composite fields (department_id, last_name) improve query performance by reducing data scan time.</p>
            </div>

            <div class="step">
                <h4>Step 2: Constraints for Data Integrity</h4>
                <pre><code>-- Creating a table with multiple constraints
CREATE TABLE departments (
    department_id INT NOT NULL,
    department_name VARCHAR(100) NOT NULL,
    location VARCHAR(50),
    CONSTRAINT pk_department PRIMARY KEY (department_id),
    CONSTRAINT uk_dept_name UNIQUE (department_name),
    CONSTRAINT chk_location CHECK (location IN ('New York', 'London', 'Tokyo'))
);

-- Adding foreign key constraint to employees table
ALTER TABLE employees
ADD CONSTRAINT fk_employee_dept FOREIGN KEY (department_id)
REFERENCES departments(department_id);
</code></pre>
                <p>Constraints like <strong>PRIMARY KEY</strong>, <strong>UNIQUE</strong>, <strong>FOREIGN KEY</strong>, and <strong>CHECK</strong> ensure data integrity by enforcing uniqueness, referential integrity, and valid data values. Unique indexes further support efficient uniqueness checks.</p>
            </div>

<div class="step">
    <h4>Step 3: Index Types - Clustered vs Non-Clustered (with Examples)</h4>
    <pre><code>-- 1. Clustered Index (Single-column)
CREATE CLUSTERED INDEX idx_salary ON employees(salary);

-- 2. Non-Clustered Index (Single-column)
CREATE NONCLUSTERED INDEX idx_lastname ON employees(last_name);

-- 3. Composite Index (Multiple columns)
CREATE NONCLUSTERED INDEX idx_name_dept ON employees(first_name, last_name, department_id);

-- 4. Unique Index (Prevents duplicates)
CREATE UNIQUE NONCLUSTERED INDEX idx_unique_email ON employees(email);

-- 5. Filtered Index (Only for rows that match condition)
CREATE NONCLUSTERED INDEX idx_active_employees ON employees(last_name)
WHERE termination_date IS NULL;
</code></pre>

    <p>
        <strong>1. Clustered Index:</strong> Physically sorts table data by one column. Only ONE per table.<br>
        <em>Use for:</em> Range queries like salary between values or date ranges<br>
        <code>SELECT * FROM employees WHERE salary BETWEEN 40000 AND 60000;</code><br><br>

        <strong>2. Non-Clustered Index:</strong> Creates separate lookup structure pointing to table rows.<br>
        <em>Use for:</em> Fast searches on frequently queried columns<br>
        <code>SELECT * FROM employees WHERE last_name = 'Smith';</code><br><br>

        <strong>3. Composite Index:</strong> Covers multiple columns together for combined searches.<br>
        <em>Use for:</em> Queries filtering on multiple columns simultaneously<br>
        <code>SELECT * FROM employees WHERE first_name = 'John' AND last_name = 'Doe';</code><br><br>

        <strong>4. Unique Index:</strong> Prevents duplicate values while speeding up searches.<br>
        <em>Use for:</em> Columns that must be unique (email, employee ID, username)<br>
        <em>Benefit:</em> Database automatically rejects duplicate entries<br><br>

        <strong>5. Filtered Index:</strong> Only indexes rows meeting specific conditions.<br>
        <em>Use for:</em> When you frequently query subsets of data (active records, recent orders)<br>
        <code>SELECT * FROM employees WHERE department = 'IT' AND termination_date IS NULL;</code><br><br>

        <strong>Key Benefits:</strong> Faster query execution, reduced table scans, improved data integrity, and efficient storage usage.
    </p>
</div>


        </div>
    </div>
